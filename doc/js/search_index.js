var search_data = {"index":{"searchIndex":["dsl","dslsetup","graphtest","neat","basicneurontypes","biasneuron","inputneuron","sigmoidneuron","controller","neatsettings","critter","genotype","gene","phenotype","evaluator","evolver","expressor","graph","dependencyresolver","neatexception","neatob","neuron","operator","population","trait","object","<<()","[]()","[]()","[]()","add()","analyze!()","analyze_for_fitness!()","bias?()","bias?()","bias?()","clear_graph()","compare()","condition_boolean_vector()","controller()","controller=()","create_controller()","create_nodes()","define()","enabled?()","evaluate!()","evaluate!()","evaluate!()","evolve()","evolve()","evolve()","express()","express()","express()","express()","express!()","express!()","express!()","express!()","express_expression!()","express_genes!()","express_neurons!()","fitness()","forget!()","gaussian()","gaussian()","gen_initial_genes!()","inherited()","initialize_copy()","initialize_copy()","input?()","input?()","input?()","inputs()","mate!()","method_missing()","mutate_add_genes!()","mutate_add_neurons!()","mutate_change_gene_weights!()","mutate_change_neurons!()","mutate_perturb_gene_weights!()","mutate_reenable_genes!()","neurontypes()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new()","new_innovation()","new_innovation()","output?()","pgraph()","prepare_fitness!()","prepare_novelty!()","prepare_speciation!()","query()","random_name_generator()","ready_for_evaluation()","ready_for_expression!()","report()","resolve()","resolve!()","run()","run_engine()","sex()","speciate!()","stimulate()","to_s()","to_s()","to_s()","to_s()","uncondition_boolean_vector()","wire!()","xor()","xor()","gemfile"],"longSearchIndex":["dsl","dslsetup","graphtest","neat","neat::basicneurontypes","neat::basicneurontypes::biasneuron","neat::basicneurontypes::inputneuron","neat::basicneurontypes::sigmoidneuron","neat::controller","neat::controller::neatsettings","neat::critter","neat::critter::genotype","neat::critter::genotype::gene","neat::critter::phenotype","neat::evaluator","neat::evolver","neat::expressor","neat::graph","neat::graph::dependencyresolver","neat::neatexception","neat::neatob","neat::neuron","neat::operator","neat::population","neat::trait","object","neat::graph#<<()","neat::critter::genotype::gene::[]()","neat::critter::phenotype::[]()","neat::graph::dependencyresolver::[]()","neat::graph#add()","neat::population#analyze!()","neat::evaluator#analyze_for_fitness!()","neat::basicneurontypes::biasneuron::bias?()","neat::neuron#bias?()","neat::neuron::bias?()","neat::graph#clear_graph()","neat::critter#compare()","dsl#condition_boolean_vector()","neat::controller()","neat::controller=()","neat::create_controller()","object#create_nodes()","dsl#define()","neat::critter::genotype::gene#enabled?()","neat::critter#evaluate!()","neat::evaluator#evaluate!()","neat::population#evaluate!()","dsl#evolve()","neat::evolver#evolve()","neat::population#evolve()","neat::basicneurontypes::biasneuron#express()","neat::basicneurontypes::inputneuron#express()","neat::basicneurontypes::sigmoidneuron#express()","neat::neuron#express()","neat::critter#express!()","neat::critter::phenotype#express!()","neat::expressor#express!()","neat::population#express!()","neat::expressor#express_expression!()","neat::expressor#express_genes!()","neat::expressor#express_neurons!()","dsl#fitness()","neat::critter::genotype#forget!()","neat::gaussian()","neat::controller#gaussian()","neat::evolver#gen_initial_genes!()","neat::neuron::inherited()","neat::critter#initialize_copy()","neat::critter::genotype#initialize_copy()","neat::basicneurontypes::inputneuron::input?()","neat::neuron::input?()","neat::neuron#input?()","neat::graph#inputs()","neat::evolver#mate!()","dsl#method_missing()","neat::evolver#mutate_add_genes!()","neat::evolver#mutate_add_neurons!()","neat::evolver#mutate_change_gene_weights!()","neat::evolver#mutate_change_neurons!()","neat::evolver#mutate_perturb_gene_weights!()","neat::evolver#mutate_reenable_genes!()","neat::neuron::neurontypes()","graphtest::new()","neat::basicneurontypes::biasneuron::new()","neat::controller::new()","neat::controller::neatsettings::new()","neat::critter::new()","neat::critter::genotype::new()","neat::critter::genotype::gene::new()","neat::expressor::new()","neat::graph::dependencyresolver::new()","neat::neatob::new()","neat::population::new()","neat::new_innovation()","neat::controller#new_innovation()","neat::neuron#output?()","object#pgraph()","neat::evolver#prepare_fitness!()","neat::evolver#prepare_novelty!()","neat::evolver#prepare_speciation!()","dsl#query()","neat::random_name_generator()","neat::evaluator#ready_for_evaluation()","neat::critter#ready_for_expression!()","dsl#report()","neat::graph::dependencyresolver#resolve()","neat::graph::dependencyresolver#resolve!()","neat::controller#run()","dsl#run_engine()","neat::evolver#sex()","neat::population#speciate!()","neat::critter::phenotype#stimulate()","graphtest#to_s()","neat::critter::genotype::gene#to_s()","neat::critter::phenotype#to_s()","neat::neatob#to_s()","dsl#uncondition_boolean_vector()","neat::critter::genotype#wire!()","dslsetup#xor()","object#xor()",""],"info":[["DSL","","classes/DSL.html","","<p>RubyNEAT DSL\n<p>DSL is a doman-specific language for RubyNEAT to allow you to configure the\nNEAT engine for …\n"],["DSLSetup","","classes/DSLSetup.html","",""],["GraphTest","","classes/GraphTest.html","",""],["NEAT","","classes/NEAT.html","","<p>Neuron Types\n<p>We create all the neuron types for this system here.\n<p>RubyNEAT – a Ruby Implementation of …\n"],["NEAT::BasicNeuronTypes","","classes/NEAT/BasicNeuronTypes.html","","<p>Basic Neuron Types\n<p>Basically, the neurons (nodes) will have an instantiation to represent\ntheir places …\n"],["NEAT::BasicNeuronTypes::BiasNeuron","","classes/NEAT/BasicNeuronTypes/BiasNeuron.html","","<p>Special class of neuron that provides a bias signal.\n\n<pre>FIXME: The bias value is not behaving as expected ...</pre>\n"],["NEAT::BasicNeuronTypes::InputNeuron","","classes/NEAT/BasicNeuronTypes/InputNeuron.html","","<p>Special class of Neuron that takes input from the “real world”\n\n<pre>Name of this neuron equates to ...</pre>\n"],["NEAT::BasicNeuronTypes::SigmoidNeuron","","classes/NEAT/BasicNeuronTypes/SigmoidNeuron.html","","<p>The most commonly-used neuron for the hidden and output layers. We use\ntanh() for the sigmoid fuction …\n"],["NEAT::Controller","","classes/NEAT/Controller.html","","<p>Controller for all operations of RubyNEAT\n\n<pre>This object contails all the specifications and details for ...</pre>\n"],["NEAT::Controller::NeatSettings","","classes/NEAT/Controller/NeatSettings.html","","<p>Various parameters affecting evolution Based somewhat on the C version of\nNEAT.\n"],["NEAT::Critter","","classes/NEAT/Critter.html","","<p>Critters for NEAT\n\n<pre class=\"ruby\"><span class=\"ruby-constant\">The</span> <span class=\"ruby-constant\">Critter</span> <span class=\"ruby-keyword\">class</span> <span class=\"ruby-identifier\">comprises</span> <span class=\"ruby-identifier\">a</span> <span class=\"ruby-constant\">Genotype</span> <span class=\"ruby-keyword\">and</span> <span class=\"ruby-identifier\">a</span> <span class=\"ruby-constant\">Phenotype</span>.\n<span class=\"ruby-constant\">The</span> <span class=\"ruby-constant\">Genotype</span> <span class=\"ruby-identifier\">comprises</span> <span class=\"ruby-constant\">Genes</span> <span class=\"ruby-operator\">...</span>\n</pre>\n"],["NEAT::Critter::Genotype","","classes/NEAT/Critter/Genotype.html","","<p>Genotype part of the Critter\n\n<pre>List of connections, basically.\n\nAlso, basic phentypic expression (which ...</pre>\n"],["NEAT::Critter::Genotype::Gene","","classes/NEAT/Critter/Genotype/Gene.html","","<p>Gene Specification\n\n<pre>The Gene specifices a singlular input and\noutput neuron, which represents a connection ...</pre>\n"],["NEAT::Critter::Phenotype","","classes/NEAT/Critter/Phenotype.html","","<p>Phenotype part of the Critter\n\n<pre>This is created by Evolver.</pre>\n"],["NEAT::Evaluator","","classes/NEAT/Evaluator.html","","<p>Evaluator evaluates phenotype of critter for fitness, novelty, etc.\n\n<pre>We can have a chain of these evaluators ...</pre>\n"],["NEAT::Evolver","","classes/NEAT/Evolver.html","","<p>Evolver – Basis of all evolvers.\n\n<pre>All evolvers shall derive from this basic evolver (or this one can be ...</pre>\n"],["NEAT::Expressor","","classes/NEAT/Expressor.html","","<p>Basis of all expressors. \n\n<pre>Expressor object turn genotypes into phenotypes.</pre>\n"],["NEAT::Graph","","classes/NEAT/Graph.html","","<p>General graph representation (mainly used for Neurons, but could be used\nfor other structures.)\n<p>This is …\n"],["NEAT::Graph::DependencyResolver","","classes/NEAT/Graph/DependencyResolver.html","","<p>Create an instantiation of this and pass it a list of nodes to resolve.\n"],["NEAT::NeatException","","classes/NEAT/NeatException.html","",""],["NEAT::NeatOb","","classes/NEAT/NeatOb.html","","<p>Basis of all NEAT objects\n"],["NEAT::Neuron","","classes/NEAT/Neuron.html","","<p>Neuron – Basis of all Neat Neuron types.\n\n<pre>Normally contains primatives which aids in its\nown expression, ...</pre>\n"],["NEAT::Operator","","classes/NEAT/Operator.html","","<p>Base class of operators in RubyNEAT,\n\n<pre>Such as Evolver, etc.</pre>\n"],["NEAT::Population","","classes/NEAT/Population.html","","<p>Population of NEAT Critters.\n\n<pre>The Population \nIn ourselves we have the pool of neurons the critters all ...</pre>\n"],["NEAT::Trait","","classes/NEAT/Trait.html","","<p>Traits\n\n<pre>A Trait is a group of parameters that can be expressed     \nas a group more than one time.  Traits ...</pre>\n"],["Object","","classes/Object.html","",""],["<<","NEAT::Graph","classes/NEAT/Graph.html#method-i-3C-3C","(input)",""],["[]","NEAT::Critter::Genotype::Gene","classes/NEAT/Critter/Genotype/Gene.html#method-c-5B-5D","(genotype, input, output, weight = 0.0)","<p>Create a new Gene and set it up fully.\n"],["[]","NEAT::Critter::Phenotype","classes/NEAT/Critter/Phenotype.html#method-c-5B-5D","(critter)",""],["[]","NEAT::Graph::DependencyResolver","classes/NEAT/Graph/DependencyResolver.html#method-c-5B-5D","(*outs)","<p>Create a DepedencyResolver from either an array of outputs or a parmeter\nlist of outputs.\n"],["add","NEAT::Graph","classes/NEAT/Graph.html#method-i-add","(input)","<p>Add a single input\n"],["analyze!","NEAT::Population","classes/NEAT/Population.html#method-i-analyze-21","()","<p>Alalyze evaluation results.\n"],["analyze_for_fitness!","NEAT::Evaluator","classes/NEAT/Evaluator.html#method-i-analyze_for_fitness-21","(critter)","<p>Analyze the evaluation and compute a fitness for the given critter.\n"],["bias?","NEAT::BasicNeuronTypes::BiasNeuron","classes/NEAT/BasicNeuronTypes/BiasNeuron.html#method-c-bias-3F","()",""],["bias?","NEAT::Neuron","classes/NEAT/Neuron.html#method-i-bias-3F","()",""],["bias?","NEAT::Neuron","classes/NEAT/Neuron.html#method-c-bias-3F","()",""],["clear_graph","NEAT::Graph","classes/NEAT/Graph.html#method-i-clear_graph","()","<p>clear and initialize the graph.\n"],["compare","NEAT::Critter","classes/NEAT/Critter.html#method-i-compare","(oc)","<p>Compare ourselves against another critter for compability.\n<p>The function to be used here is:\n\n<pre>distance = ...</pre>\n"],["condition_boolean_vector","DSL","classes/DSL.html#method-i-condition_boolean_vector","(vec)","<p>Helper function to Condition boolean vectors to be +1 if true, -1 if false\n"],["controller","NEAT","classes/NEAT.html#method-c-controller","()",""],["controller=","NEAT","classes/NEAT.html#method-c-controller-3D","(controller)",""],["create_controller","NEAT","classes/NEAT.html#method-c-create_controller","(*parms)",""],["create_nodes","Object","classes/Object.html#method-i-create_nodes","(n)",""],["define","DSL","classes/DSL.html#method-i-define","(name = NEAT.random_name_generator, &block)","<p>DSL – Define defines the parameters to the controller.\n"],["enabled?","NEAT::Critter::Genotype::Gene","classes/NEAT/Critter/Genotype/Gene.html#method-i-enabled-3F","()",""],["evaluate!","NEAT::Critter","classes/NEAT/Critter.html#method-i-evaluate-21","()","<p>A single evaluation step. Evaluate and generate fitness, novelty, etc.\nReturns the result.\n"],["evaluate!","NEAT::Evaluator","classes/NEAT/Evaluator.html#method-i-evaluate-21","(critter)","<p>Evaluate one step of a sequence of evaluations. For time series and\nrealtime ongoing evaluations, @controller.seq_num …\n"],["evaluate!","NEAT::Population","classes/NEAT/Population.html#method-i-evaluate-21","()","<p>Called for each sequence.\n"],["evolve","DSL","classes/DSL.html#method-i-evolve","(&block)","<p>DSL – Run evolution\n"],["evolve","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-evolve","(population)","<p>Here we clone the population and then evolve it on the basis of fitness and\nnovelty, etc.\n<p>Returns  the …\n"],["evolve","NEAT::Population","classes/NEAT/Population.html#method-i-evolve","()","<p>Call this after evaluation. Returns a newly-evolved population.\n"],["express","NEAT::BasicNeuronTypes::BiasNeuron","classes/NEAT/BasicNeuronTypes/BiasNeuron.html#method-i-express","(instance)","<p>Just provides a bias signal\n"],["express","NEAT::BasicNeuronTypes::InputNeuron","classes/NEAT/BasicNeuronTypes/InputNeuron.html#method-i-express","(instance)","<p>Takes a single input and passes it as is.\n"],["express","NEAT::BasicNeuronTypes::SigmoidNeuron","classes/NEAT/BasicNeuronTypes/SigmoidNeuron.html#method-i-express","(instance)","<p>create a function on the instance with our name that sums all inputs and\nproduce a sigmoid output (using …\n"],["express","NEAT::Neuron","classes/NEAT/Neuron.html#method-i-express","(instance)","<p>Function must be implemented by subclasses for phenotype generation.\nBasically, an instance is passed …\n"],["express!","NEAT::Critter","classes/NEAT/Critter.html#method-i-express-21","()","<p>Exoress this critter using the Expressor plugin.\n"],["express!","NEAT::Critter::Phenotype","classes/NEAT/Critter/Phenotype.html#method-i-express-21","()","<p>Take what is in code and express that!\n"],["express!","NEAT::Expressor","classes/NEAT/Expressor.html#method-i-express-21","(critter)","<p>Take the genotype of the critter and create a phenotype from the genotype.\n<p>In the phenotype, it creates …\n"],["express!","NEAT::Population","classes/NEAT/Population.html#method-i-express-21","()","<p>Express the entire population.\n"],["express_expression!","NEAT::Expressor","classes/NEAT/Expressor.html#method-i-express_expression-21","(critter)",""],["express_genes!","NEAT::Expressor","classes/NEAT/Expressor.html#method-i-express_genes-21","(critter)","<p>What this really does is create the function that calls all the functions.\n<p>This makes use of the Graph …\n"],["express_neurons!","NEAT::Expressor","classes/NEAT/Expressor.html#method-i-express_neurons-21","(critter)","<p>Express Neurons as methods\n"],["fitness","DSL","classes/DSL.html#method-i-fitness","(&block)","<p>fitness function calls the block with 2 vectors or two hashes, input and\noutput vectors of the critter …\n"],["forget!","NEAT::Critter::Genotype","classes/NEAT/Critter/Genotype.html#method-i-forget-21","()","<p>Make the neurons forget their wiring.\n"],["gaussian","NEAT","classes/NEAT.html#method-c-gaussian","()",""],["gaussian","NEAT::Controller","classes/NEAT/Controller.html#method-i-gaussian","()",""],["gen_initial_genes!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-gen_initial_genes-21","(genotype)","<p>Generate the initial genes for a given genotype. We key genes off their\ninnovation numbers.\n"],["inherited","NEAT::Neuron","classes/NEAT/Neuron.html#method-c-inherited","(clazz)",""],["initialize_copy","NEAT::Critter","classes/NEAT/Critter.html#method-i-initialize_copy","(source)","<p>We deep-copy the genotype here, since we obviously need it to be seperate.\n"],["initialize_copy","NEAT::Critter::Genotype","classes/NEAT/Critter/Genotype.html#method-i-initialize_copy","(source)","<p>Deep-copy the neurons and genes. Question: Do we really need to deep-copy\nthe neurons? There is the possibility …\n"],["input?","NEAT::BasicNeuronTypes::InputNeuron","classes/NEAT/BasicNeuronTypes/InputNeuron.html#method-c-input-3F","()",""],["input?","NEAT::Neuron","classes/NEAT/Neuron.html#method-c-input-3F","()","<p>Class is is of Input type?\n"],["input?","NEAT::Neuron","classes/NEAT/Neuron.html#method-i-input-3F","()",""],["inputs","NEAT::Graph","classes/NEAT/Graph.html#method-i-inputs","()","<p>Get list of inputs\n"],["mate!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mate-21","()","<p>Here we select candidates for mating. We must look at species and fitness\nto make the selection for mating. …\n"],["method_missing","DSL","classes/DSL.html#method-i-method_missing","(m, *args, &block)","<p>This is used to handle the details of our DSL.\n"],["mutate_add_genes!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mutate_add_genes-21","()",""],["mutate_add_neurons!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mutate_add_neurons-21","()",""],["mutate_change_gene_weights!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mutate_change_gene_weights-21","()",""],["mutate_change_neurons!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mutate_change_neurons-21","()",""],["mutate_perturb_gene_weights!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mutate_perturb_gene_weights-21","()","<p>Perturb existing gene weights by adding a guassian to them.\n"],["mutate_reenable_genes!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-mutate_reenable_genes-21","()",""],["neuronTypes","NEAT::Neuron","classes/NEAT/Neuron.html#method-c-neuronTypes","()","<p>List of distinct neuron types (classes)\n"],["new","GraphTest","classes/GraphTest.html#method-c-new","(i)",""],["new","NEAT::BasicNeuronTypes::BiasNeuron","classes/NEAT/BasicNeuronTypes/BiasNeuron.html#method-c-new","(c=nil, n=nil)",""],["new","NEAT::Controller","classes/NEAT/Controller.html#method-c-new","(neural_inputs = nil, neural_outputs = nil, parameters = NeatSettings.new)","<p>neural_inputs – array of input classes\n<p>neural_outputs – array of output classes\n<p>parameters – NeatParameters …\n"],["new","NEAT::Controller::NeatSettings","classes/NEAT/Controller/NeatSettings.html#method-c-new","()","<p>Set up defaults for mandatory entries.\n"],["new","NEAT::Critter","classes/NEAT/Critter.html#method-c-new","(pop, mating = false)","<p>Critter construction. We construct the genotype. The phenotype will be\nconstructed by the Expressor operator. …\n"],["new","NEAT::Critter::Genotype","classes/NEAT/Critter/Genotype.html#method-c-new","(critter, mating = false)",""],["new","NEAT::Critter::Genotype::Gene","classes/NEAT/Critter/Genotype/Gene.html#method-c-new","(genotype)",""],["new","NEAT::Expressor","classes/NEAT/Expressor.html#method-c-new","(c)",""],["new","NEAT::Graph::DependencyResolver","classes/NEAT/Graph/DependencyResolver.html#method-c-new","(outputs)","<p>Given a list of output nodes, we shall work backwards from them to resolve\ntheir dependencies.\n"],["new","NEAT::NeatOb","classes/NEAT/NeatOb.html#method-c-new","(controller = nil, name = nil)",""],["new","NEAT::Population","classes/NEAT/Population.html#method-c-new","(c)","<p>Create initial (ramdom) population of critters\n"],["new_innovation","NEAT","classes/NEAT.html#method-c-new_innovation","()",""],["new_innovation","NEAT::Controller","classes/NEAT/Controller.html#method-i-new_innovation","()",""],["output?","NEAT::Neuron","classes/NEAT/Neuron.html#method-i-output-3F","()","<p>Instantiation is of outout type?\n"],["pgraph","Object","classes/Object.html#method-i-pgraph","(a, mess)",""],["prepare_fitness!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-prepare_fitness-21","()","<p>Sort species within the basis of fitness\n"],["prepare_novelty!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-prepare_novelty-21","()",""],["prepare_speciation!","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-prepare_speciation-21","()","<p>Here we specify evolutionary operators.\n"],["query","DSL","classes/DSL.html#method-i-query","(&block)","<p>Query function is called with the sequence (time evalution) number, and\nreturns an array or hash of parameters …\n"],["random_name_generator","NEAT","classes/NEAT.html#method-c-random_name_generator","()",""],["ready_for_evaluation","NEAT::Evaluator","classes/NEAT/Evaluator.html#method-i-ready_for_evaluation","()","<p>This is call prior to any sequence evaluation. Here, we clean up persistent\ntracking information, etc. …\n"],["ready_for_expression!","NEAT::Critter","classes/NEAT/Critter.html#method-i-ready_for_expression-21","()","<p>Get the Critter ready for the Expressor to express the geneotype.\n"],["report","DSL","classes/DSL.html#method-i-report","(&block)","<p>Report on evaluations\n"],["resolve","NEAT::Graph::DependencyResolver","classes/NEAT/Graph/DependencyResolver.html#method-i-resolve","()","<p>Resolve dependencies, and return [dependency_list, circular_ref_node_list]\nNote that circular_ref_node_list …\n"],["resolve!","NEAT::Graph::DependencyResolver","classes/NEAT/Graph/DependencyResolver.html#method-i-resolve-21","()","<p>Throw an exception if dependencies are found. We only return the dependency\nlist since we throw an exception …\n"],["run","NEAT::Controller","classes/NEAT/Controller.html#method-i-run","()","<p>Run this evolution.\n"],["run_engine","DSL","classes/DSL.html#method-i-run_engine","(&block)","<p>Run the engine. The block is called on each generation.\n"],["sex","NEAT::Evolver","classes/NEAT/Evolver.html#method-i-sex","(crit1, crit2)","<p>mate the given critters and return a baby.\n"],["speciate!","NEAT::Population","classes/NEAT/Population.html#method-i-speciate-21","()","\n<pre>Group crtters into species\nNote that the @species objects\nhave useful singleton methods:</pre>\n<p>@species.member …\n"],["stimulate","NEAT::Critter::Phenotype","classes/NEAT/Critter/Phenotype.html#method-i-stimulate","()","<p>This function is re-written by Expressor – with parameters and all. It\nreturns a “response” …\n"],["to_s","GraphTest","classes/GraphTest.html#method-i-to_s","()",""],["to_s","NEAT::Critter::Genotype::Gene","classes/NEAT/Critter/Genotype/Gene.html#method-i-to_s","()",""],["to_s","NEAT::Critter::Phenotype","classes/NEAT/Critter/Phenotype.html#method-i-to_s","()","<p>This gives us a complete\n"],["to_s","NEAT::NeatOb","classes/NEAT/NeatOb.html#method-i-to_s","()",""],["uncondition_boolean_vector","DSL","classes/DSL.html#method-i-uncondition_boolean_vector","(vec)","<p>Helper function to Uncondition boolean vectors to be +1 if true, -1 if\nfalse\n"],["wire!","NEAT::Critter::Genotype","classes/NEAT/Critter/Genotype.html#method-i-wire-21","()","<p>Wire up the neurons based on the genes.\n"],["xor","DSLSetup","classes/DSLSetup.html#method-i-xor","(*inp)","<p>Basic xor function we shall evolve a net for. Only goes true on one and\nonly one true input, false otherwise. …\n"],["xor","Object","classes/Object.html#method-i-xor","(*inp)","<p>Basic xor function we shall evolve a net for. Only goes true on one and\nonly one true input, false otherwise. …\n"],["Gemfile","","files/Gemfile.html","","<p>source ‘rubygems.org’ source ‘gems.github.com’\n<p>gem ‘mongo’ gem ‘bson_ext’ gem ‘rspec’ gem ‘distribution’ …\n"]]}}